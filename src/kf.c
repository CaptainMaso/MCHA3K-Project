#include <stdint.h>
#include <stdio.h>
#include <math.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <kf.h>
#include <util/atomic.h>

#include "mpu6050.h"
#include "encoders.h"
#include "controller.h"

#include "ctrl_param.def"

static int16_t _ax = 0;
static int16_t _ay = 0;
static int16_t _az = 0;
static int16_t _gx = 0;
static int16_t _gy = 0;
static int16_t _gz = 0;

/*
 * Kalman Filter Variables (TODO: put these in a .def file generated by matlab)
 */
#define pw 10000.0
#define pb 8000.0
#define qw 1000.0
#define qb 0.8
#define rt 2.0
#define rw 0.1

#define ps 8000.0
#define qs 1000.0
#define rp 0.001

static covariance P;		//Covariance Variables

void kf_init(void)
{
	//Initialise MPU6050
	mpu6050_init();

	mpu6050_getRawData(&_ax, &_ay, &_az, &_gx, &_gy, &_gz);

	//Initialise Kalman Filter
	P.WW = T_KF*pw;
	P.WT = T_KF*T_KF*pw/2;
	P.WB = 0;
	P.TT = T_KF*T_KF*T_KF*pw/3;
	P.TB = 0;
	P.BB = T_KF*pb;

	P.PP_L = T_KF*T_KF*T_KF*ps/3;
	P.SP_L = T_KF*T_KF*ps/2;
	P.SS_L = T_KF*ps;

	P.PP_R = T_KF*T_KF*T_KF*ps/3;
	P.SP_R = T_KF*T_KF*ps/2;
	P.SS_R = T_KF*ps;
}

void kf_correct(states *curState)
{
	mpu6050_getRawData(&_ax, &_ay, &_az, &_gx, &_gy, &_gz);
	//_gy += 2621;
	kf_gyrocorrection(-_gy, curState);
	kf_acccorrection(imu_get_atanTheta(), curState);
	kf_enccorrection(MOTOR_LEFT, encoder_get_count(MOTOR_LEFT)*2*3.14159/CPR,curState);
	kf_enccorrection(MOTOR_RIGHT, encoder_get_count(MOTOR_RIGHT)*2*3.14159/CPR,curState);
}

void kf_timestep(float TimeStep, states *curState)
{
	//State Update
	curState->Theta 	= TimeStep*curState->dTheta + curState->Theta;
	//curState->dTheta 	= curState->dTheta;
	//curState->Bias 		= curState->Bias;

	//curState->dPhi_ML   = curState->dPhi_ML;
	//curState->dPhi_MR   = curState->dPhi_MR;
	curState->Phi_ML	= TimeStep*curState->dPhi_ML + curState->Phi_ML;
	curState->Phi_MR	= TimeStep*curState->dPhi_MR + curState->Phi_MR;

	//Covariance Update
	covariance P_n;		//Covariance Variables

	P_n.BB = P.BB 													+ TimeStep					*qb;
	P_n.TB = P.TB 	+ TimeStep*P.WB;
	P_n.TT = P.TT 	+ TimeStep*TimeStep*P.WW + 2*TimeStep*P.WT 		+ TimeStep*TimeStep*TimeStep*qw/3;
	P_n.WB = P.WB;
	P_n.WT = P.WT 	+ P.WW*TimeStep 								+ TimeStep*TimeStep			*qw/2;
	P_n.WW = P.WW 													+ TimeStep					*qw;

	P_n.PP_L = P.PP_L + 2*P.SP_L*TimeStep 	+ TimeStep*TimeStep*TimeStep	*qs/3;
	P_n.SP_L = P.SP_L + P.SS_L*TimeStep 	+ TimeStep*TimeStep				*qs/2;
	P_n.SS_L = P.SS_L + TimeStep * qs;

	P_n.PP_R = P.PP_R + 2*P.SP_R*TimeStep 	+ TimeStep*TimeStep*TimeStep	*qs/3;
	P_n.SP_R = P.SP_R + P.SS_R*TimeStep 	+ TimeStep*TimeStep				*qs/2;
	P_n.SS_R = P.SS_R + TimeStep * qs;

	P = P_n;
}

void kf_gyrocorrection(float yw, states *curState)
{
	// Kalman Gain
	float divider = 1.0/(P.WW+ 2*P.WB+ P.BB+ rw/T_KF);
	float kw = (P.WW + P.WB)*divider;
	float kt = (P.WT + P.TB)*divider;
	float kb = (P.WB + P.BB)*divider;

	// State Correction
	float error = (yw-curState->dTheta-curState->Bias);
	curState->dTheta 	=  curState->dTheta + kw*error;
	curState->Theta 	=  curState->Theta 	+ kt*error;
	curState->Bias 		=  curState->Bias 	+ kb*error;

	// Covariance Correction
	covariance P_n = P;		//Covariance Variables

	P_n.WW = - P.WB*kw 	- P.WW*(kw - 1);
	P_n.WT = - P.TB*kw 	- P.WT*(kw - 1);
	P_n.WB = - P.BB*kw 	- P.WB*(kw - 1);
	P_n.TT =   P.TT 	- P.TB*kt 		- P.WT*kt;
	P_n.TB =   P.TB 	- P.BB*kt 		- P.WB*kt;
	P_n.BB = - P.WB*kb 	- P.BB*(kb - 1);

	P = P_n;
}

void kf_acccorrection(float yt, states *curState)
{
	// Kalman Gain
	float divider = 1.0/(P.TT+ rt/T_KF);
	float kw = P.WT*divider;
	float kt = P.TT*divider;
	float kb = P.TB*divider;

	// State Correction
	float error 		= (yt-curState->Theta);
	curState->dTheta 	=  curState->dTheta + kw*error;
	curState->Theta 	=  curState->Theta 	+ kt*error;
	curState->Bias 		=  curState->Bias 	+ kb*error;

	// Covariance Correction
	covariance P_n = P;		//Covariance Variables

	P_n.WW = P.WW 	- P.WT*kw;
	P_n.WT = P.WT 	- P.TT*kw;
	P_n.WB = P.WB 	- P.TB*kw;
	P_n.TT = P.TT*(1-kt);
	P_n.TB = P.TB*(1-kt);
	P_n.BB = P.BB 	- P.TB*kb;

	P = P_n;
}

void kf_enccorrection(MOTOR_SIDE side, float phi, states *curState)
{
	switch (side)
	{
	case MOTOR_LEFT:
	{
		// Kalman Gain
		float divider = 1.0/(P.PP_L + rp/T_KF);
		float kp = P.PP_L*divider;
		float ks = P.SP_L*divider;

		// State Correction
		float error 		= (phi - curState->Phi_ML);
		curState->Phi_ML 	=  curState->Phi_ML 	+ kp*error;
		curState->dPhi_ML 	=  curState->dPhi_ML 	+ ks*error;

		// Covariance Correction
		covariance P_n = P;		//Covariance Variables

		P_n.PP_L = -P.PP_L*(kp - 1);
		P_n.SP_L = -P.SP_L*(kp - 1);
		P_n.SS_L = P.SS_L - P.SP_L*ks;

		P = P_n;
	} break;
	case MOTOR_RIGHT:
	{
		// Kalman Gain
		float divider = 1.0/(P.PP_R + rp/T_KF);
		float kp = P.PP_R*divider;
		float ks = P.SP_R*divider;

		// State Correction
		float error 		= (phi - curState->Phi_MR);
		curState->Phi_MR 	=  curState->Phi_MR 	+ kp*error;
		curState->dPhi_MR 	=  curState->dPhi_MR 	+ ks*error;

		// Covariance Correction
		covariance P_n = P;		//Covariance Variables

		P_n.PP_R = -P.PP_R*(kp - 1);
		P_n.SP_R = -P.SP_R*(kp - 1);
		P_n.SS_R = P.SS_R - P.SP_R*ks;

		P = P_n;
	} break;
	default:
		break;
	}
}

int16_t imu_get_atanTheta(void)
{
	return (int16_t)(atan2(-(_az + AX_OFFSET), _ax + AX_OFFSET)*RAD2DEG/*/(THETAGAIN)*/) + ATAN_OFFSET;
}

int16_t imu_get_ax(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _ax + AX_OFFSET;
	}

	return tmp;
}
int16_t imu_get_ay(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _ay;
	}

	return tmp;
}
int16_t imu_get_az(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _az+ AZ_OFFSET;
	}

	return tmp;
}
int16_t imu_get_gx(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _gx;
	}

	return tmp;
}
int16_t imu_get_gy(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _gy;
	}

	return tmp;
}
int16_t imu_get_gz(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _gz;
	}

	return tmp;
}

