#include <stdint.h>
#include <stdio.h>
#include <math.h>
#include <stdbool.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/atomic.h>

#include "task.h"

#include "imu.h"
#include "mpu6050.h"

void imu_correct(void);

static task_s _imu_update_task = {
		.interval = 10,
		.callback = imu_correct,
		.id = 255
};

static int16_t _ax = 0;
static int16_t _ay = 0;
static int16_t _az = 0;
static int16_t _gx = 0;
static int16_t _gy = 0;
static int16_t _gz = 0;

/*
 * Kalman Filter Variables (TODO: put these in a .def file generated by matlab)
 */
#define pw 880
#define pb 100
#define qw 867
#define qb 0.000008
#define rt 10
#define rw 0.0004

const float RW_T = rw/IMU_T;
const float RT_T = rt/IMU_T;

static imu_kalman_state imu_est;

void imu_init(void)
{
	//Initialise MPU6050
	mpu6050_init();

	//Set up IMU task regularly update data
	_imu_update_task.interval = tasks_time_interval_to_task_interval(IMU_T);

	//Initialise Kalman Filter
	imu_est.Pcov[COV_WW] = IMU_T*pw;
	imu_est.Pcov[COV_WT] = IMU_T*IMU_T*pw/2;
	imu_est.Pcov[COV_WB] = 0;
	imu_est.Pcov[COV_TT] = IMU_T*IMU_T*IMU_T*pw/3;
	imu_est.Pcov[COV_TB] = 0;
	imu_est.Pcov[COV_BB] = IMU_T*pb;

	mpu6050_getRawData(&_ax, &_ay, &_az, &_gx, &_gy, &_gz);

	imu_est.Theta = imu_get_atanTheta();///THETAGAIN;
	imu_est.dTheta = 0;
	imu_est.Bias = 0;

	tasks_add(&_imu_update_task);
}

void _imu_gyrocorrection(float yw);
void _imu_acccorrection(float yt);

void imu_correct(void)
{
	mpu6050_getRawData(&_ax, &_ay, &_az, &_gx, &_gy, &_gz);
	//_gy += 2621;
	_imu_gyrocorrection(-(float)_gy);
	_imu_acccorrection(imu_get_atanTheta());
	PORTD &= ~(_BV(PA7));
}

void imu_timestep(float TimeStep)
{
	imu_kalman_state nextStep;

	//State Update
	nextStep.Theta 	= TimeStep*imu_est.dTheta + imu_est.Theta;
	nextStep.dTheta = imu_est.dTheta;
	nextStep.Bias 	= imu_est.Bias;

	//Covariance Update
	nextStep.Pcov[COV_BB] = imu_est.Pcov[COV_BB] + TimeStep*qb;
	nextStep.Pcov[COV_TB] = TimeStep*imu_est.Pcov[COV_WB]+imu_est.Pcov[COV_TB];
	nextStep.Pcov[COV_TT] = imu_est.Pcov[COV_TT] + TimeStep*TimeStep*imu_est.Pcov[COV_WW] + 2*TimeStep*imu_est.Pcov[COV_WT] + TimeStep*TimeStep*TimeStep*qw/3;
	nextStep.Pcov[COV_WB] = imu_est.Pcov[COV_WB];
	nextStep.Pcov[COV_WT] = TimeStep*imu_est.Pcov[COV_WW] + imu_est.Pcov[COV_WT] + TimeStep*TimeStep*qw/2;
	nextStep.Pcov[COV_WW] = imu_est.Pcov[COV_WW] + TimeStep*qw;

	imu_est = nextStep;
}

void _imu_gyrocorrection(float yw)
{
	imu_kalman_state nextStep;

	// Kalman Gain
	float divider = 1.0/(imu_est.Pcov[COV_WW]+ 2*imu_est.Pcov[COV_WB]+ imu_est.Pcov[COV_BB]+ rw/IMU_T);
	float kw = (imu_est.Pcov[COV_WW] + imu_est.Pcov[COV_WB])*divider;
	float kt = (imu_est.Pcov[COV_WT] + imu_est.Pcov[COV_TB])*divider;
	float kb = (imu_est.Pcov[COV_WB] + imu_est.Pcov[COV_BB])*divider;

	// State Correction
	float error = (yw-imu_est.dTheta-imu_est.Bias);
	nextStep.dTheta = imu_est.dTheta 	+ kw*error;
	nextStep.Theta =  imu_est.Theta 	+ kt*error;
	nextStep.Bias =   imu_est.Bias 		+ kb*error;

	// Covariance Correction
	nextStep.Pcov[COV_WW] = - imu_est.Pcov[COV_WB]*kw 	- imu_est.Pcov[COV_WW]*(kw - 1);
	nextStep.Pcov[COV_WT] = - imu_est.Pcov[COV_TB]*kw 	- imu_est.Pcov[COV_WT]*(kw - 1);
	nextStep.Pcov[COV_WB] = - imu_est.Pcov[COV_BB]*kw 	- imu_est.Pcov[COV_WB]*(kw - 1);
	nextStep.Pcov[COV_TT] =   imu_est.Pcov[COV_TT] 		- imu_est.Pcov[COV_TB]*kt 		- imu_est.Pcov[COV_WT]*kt;
	nextStep.Pcov[COV_TB] =   imu_est.Pcov[COV_TB] 		- imu_est.Pcov[COV_BB]*kt 		- imu_est.Pcov[COV_WB]*kt;
	nextStep.Pcov[COV_BB] = - imu_est.Pcov[COV_WB]*kb 	- imu_est.Pcov[COV_BB]*(kb - 1);

	imu_est = nextStep;
}

void _imu_acccorrection(float yt)
{
	imu_kalman_state nextStep;

	// Kalman Gain
	float divider = 1.0/(imu_est.Pcov[COV_TT]+ rt/IMU_T);
	float kw = imu_est.Pcov[COV_WT]*divider;
	float kt = imu_est.Pcov[COV_TT]*divider;
	float kb = imu_est.Pcov[COV_TB]*divider;

	// State Correction
	float error 	= (yt-imu_est.Theta);
	nextStep.dTheta = imu_est.dTheta 	+ kw*error;
	nextStep.Theta 	=  imu_est.Theta 	+ kt*error;
	nextStep.Bias 	=   imu_est.Bias 	+ kb*error;

	// Covariance Correction
	nextStep.Pcov[COV_WW] =  imu_est.Pcov[COV_WW] 	- imu_est.Pcov[COV_WT]*kw;
	nextStep.Pcov[COV_WT] =  imu_est.Pcov[COV_WT] 	- imu_est.Pcov[COV_TT]*kw;
	nextStep.Pcov[COV_WB] =  imu_est.Pcov[COV_WB] 	- imu_est.Pcov[COV_TB]*kw;
	nextStep.Pcov[COV_TT] = -imu_est.Pcov[COV_TT]*(kt - 1);
	nextStep.Pcov[COV_TB] = -imu_est.Pcov[COV_TB]*(kt - 1);
	nextStep.Pcov[COV_BB] =  imu_est.Pcov[COV_BB] 	- imu_est.Pcov[COV_TB]*kb;

	imu_est = nextStep;
}

float imu_get_atanTheta(void)
{
	return atan2(-(_az + AX_OFFSET), _ax + AX_OFFSET)/THETAGAIN;
}

float imu_get_Theta(void)
{
	return imu_est.Theta;
}

float imu_get_dTheta(void)
{
	return imu_est.dTheta;
}

float imu_get_Bias(void)
{
	return imu_est.Bias;
}

int16_t imu_get_ax(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _ax + AX_OFFSET;
	}

	return tmp;
}
int16_t imu_get_ay(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _ay;
	}

	return tmp;
}
int16_t imu_get_az(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _az+ AZ_OFFSET;
	}

	return tmp;
}
int16_t imu_get_gx(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _gx;
	}

	return tmp;
}
int16_t imu_get_gy(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _gy;
	}

	return tmp;
}
int16_t imu_get_gz(void)
{
	int16_t tmp;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		tmp = _gz;
	}

	return tmp;
}

float imu_get_PWW(void)
{
	return imu_est.Pcov[COV_WW];
}

float imu_get_PTT(void)
{
	return imu_est.Pcov[COV_TT];
}

float imu_get_PBB(void)
{
	return imu_est.Pcov[COV_BB];
}

